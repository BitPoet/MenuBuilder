<?php

/**
* Markup Menu Builder Module for ProcessWire
* This module enables you to display on your website custom menus built using ProcessMenuBuilder
*
* @author Kongondo
*
* https://github.com/kongondo/ProcessMenuBuilder
* Created 1 September 2013
* Major update in March 2015
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class MarkupMenuBuilder extends WireData implements Module {
	
	/**
	 * Return information about this module (required)
	 * @ Requires ProcessMenubuilder
	 *
	 */
	
	public static function getModuleInfo() {
	
		return array(
			'title' => 'Markup Menu Builder',
			'summary' => 'Render menus created by Menu Builder',
			'author' => 'Kongondo',
			'version' => 7,
			'href' => 'http://processwire.com/talk/topic/4451-module-menu-builder/',
			'singular' => true, 
			'autoload' => false, 
			'requires' => 'ProcessMenuBuilder'
		);

	}

	/**
	* Initialise the module. This is an optional initialisation method called before any execute methods.
	*	
	* Initialises various class properties ready for use throughout the class.
	*
	* @access public
	*
	*/	
	public function init() {
		//required
	
	}
		
	/**
	* Pass on menu items for processing and rendering.
	* 
	* This is just a method that the user interfaces with.
	* The processing work is done by other methods.
	*
	* @access public
	* @param Mixed $menu Page, ID, Title, Name of a menu or Array of menu items.
	* @param Array $options Array of menu options.
	* @return Method renderMenu().
	*
	*/		
	public function render($menu, Array $options = null) {

		//process menu items
		$menuItems = $this->processMenu($menu);
		if(!is_array($menuItems)) return $this->throwError();
		
		//processed menu options
		$options = $this->processOptions($options);
		
		//to help with 'has_children' and 'last_class'
		$parentIDs = $this->parentIDs($menuItems);

		//render the menu
		return $this->renderMenu($menuItems, $options, $parentIDs);

	}

	/**
	* Helper function to process menu items before passing on for rendering.
	* 
	* This method determines and processes $menu variable type to return an array of menu items.
*	*
	* @access private
	* @param Mixed $menu Page, ID, Title, Name of a menu or Array of menu items.
	* @return Array menuItems.
	*
	*/
	private function processMenu($menu) {

		$menuItems = '';
		
		#### - work on the menu items - ###

		//if we got a Page object
		if($menu instanceof Page) {

				$menuitemsJSON = $menu->menu_items;
				$menuItems = json_decode($menuitemsJSON, true);
		}

		//if we got a populated array of menu items
		elseif(is_array($menu)) {

			 	$menuItems = $menu;//for consistency
		}

		//if we got a menu title|name
		elseif (is_string($menu)) {

				//grab the menu
				$menuName = $this->sanitizer->pageName($menu);
				$menuParent = wire('pages')->get($this->config->adminRootPageID)->child('name=setup, check_access=0')->child('name=menu-builder, check_access=0');
				$menu = $menuParent->child("name=$menuName, check_access=0");
				if($menu) $menuItems = json_decode($menu->menu_items, true);
		}

		//if we got an id
		elseif(is_integer($menu)) {

				//grab the menu
				$menuID = (int) $menu;
				$menu = wire('pages')->get($menu);
				if($menu) $menuItems = json_decode($menu->menu_items, true);
		}
		
		return $menuItems;

	}

	/**
	* Displays a nested list (menu items) of a single menu.
	* 
	* A recursive function to display nested list of menu items.
	*
	* @access private
	* @param Array $menuItems Array of menu items to loop through and display.
	* @param Array $options Array of custom settings for menu and menu items (e.g. CSS classes).
	* @param Array $parentIDs Array of IDs of menu items that are parents/have children. Note: ID = menu IDs, not native PW!
	* @param Int $first Helper variable to designate first menu item. Ensures CSS Class 'sortable' is output only once.
	* @return string $out.
	*
	*/
	private function renderMenu(Array $menuItems, $options = null, $parentIDs = null, $parent = 0, $first = 0) {

		$total = count($menuItems);
		$cnt = 0;

		$out = "";
		$has_child = false;
		$wTag = $options['wrapper_list_type'];//item wrapper tag. default = <ul>
		$iTag = $options['list_type'];//item tag. default = <li>

		foreach ($menuItems as $id => $item) {

			//set properties
			$parentID = isset($item['parent_id']) ? $item['parent_id'] : 0;//if parent_id not set, it means they are top tier items
			$pagesID = isset($item['pages_id']) ? $item['pages_id'] : 0;//for PW pages, use their native IDs
			
			//display saved vs actual/multilingual menu title/label
			if($options['default_title'] == 0 || $pagesID == 0) $title = $item['title'];
			elseif($options['default_title'] == 1) $title = wire('pages')->get($pagesID)->title;			
			
			$url = $pagesID ? wire('pages')->get($pagesID)->url : $item['url'];//for PW pages, use their native URLs
			$newtab = isset($item['newtab']) ? "target='_blank'" : '';
			
			$itemFirst = '';

			//if this menu item is a parent; create the sub-items/child-menu-items
			if ($parentID == $parent) {

				//if this is the first child output '<ul>' or specified $wTag       
				if ($has_child === false) {
					$has_child = true;//This is a parent					
					if ($first == 0) {						
							//assign menu css id and class if provided
							$cssMenuID =  $options['menu_css_id'] ? ' id ="' . $options['menu_css_id'] . '" ' : '';
							$cssMenuClass = $options['menu_css_class'] ? 'class ="' . $options['menu_css_class'] . '"' : '';						
							$out .= "<{$wTag} {$cssMenuID} {$cssMenuClass}>" . "\n";						
							$first = 1;
					}

					else {
							//assign sub-menu classes if provided
							$cssSubMenuClass = $options['submenu_css_class'] ? 'class ="' . $options['submenu_css_class'] . '"' : '';
							$out .= "\n<{$wTag} {$cssSubMenuClass}>\n";
					}

					//first <li> item
					$itemFirst = $options['first_class'];

				}//end if has child

				//item CSS
				$itemCSSID = isset($item['css_itemid']) ? 'id="' . $item['css_itemid'] . '"' : '';
				$itemCSSClass = isset($item['css_itemclass']) ? $item['css_itemclass'] . ' ' : '';
				$itemHasChildren = isset($parentIDs[$id]) ? $options['has_children_class'] . ' ' : '';
				$itemLast = (in_array($id, $parentIDs)) || ($total - $cnt == 1) ? $options['last_class'] . ' ' : '';
				$itemCurrent = $pagesID == wire('page')->id ? $options['current_class'] . ' ' : '';

				$classes = $itemCSSClass . $itemHasChildren . $itemLast . $itemCurrent . $itemFirst;
				$classes = trim(preg_replace('/\s+/', ' ', $classes));
				$class = strlen($classes) ? 'class="' . $classes . '"' : '';
			
				//if $iTag is empty, apply css id and classes to <a> instead
				if(!$iTag) $out .= "<a {$itemCSSID} {$class} {$newtab} href='{$url}'>{$title}</a>";
				else $out .= "<{$iTag} {$itemCSSID} {$class}><a {$newtab} href='{$url}'>{$title}</a>";
 
				//call function again to generate sub-menu items belonging to this menu item. 
				$out .= $this->renderMenu($menuItems, $options, $parentIDs, $id, $first);

				$out .= $iTag ? "</{$iTag}>\n" : '';//if $iTag specified, close it
				
			}//end if $parentID == $parent

			$cnt++;
		
		}//end foreach

		if ($has_child === true) $out .= "</{$wTag}>\n";

		return $out;

	}

	/**
	* Displays a breadcrumb of menu items.
	* 
	* A recursive function to display a breadcrumb trail of menu items built of the current menu item.
	*
	* @access public
	* @param Mixed $menu Page, ID, Title, Name of a menu or Array of menu items.
	* @param Array $options Array of markup options for displaying the breadcrumb.
	* @return string $out.
	*
	*/
	public function renderBreadcrumbs($menu, Array $options = null) {

		$itemIDs = '';
		$menuItemsIDs = '';

		$menuItems = $this->processMenu($menu);
		//exit with error if no menu items found
		if(!is_array($menuItems)) return $this->throwError();

		$options = $this->processOptions($options);

		//grab menu item that matches the current page (i.e. where we currently are in the breadcrumb trail)
		$currentItem = array_filter($menuItems, function($pid) {
			if(isset($pid['pages_id'])) return ($pid['pages_id'] == wire('page')->id);
		});

		//if method called on page that is not part of the breadcrumb navigation, exit with error
		if(!count($currentItem)) $this->throwError();

		//grab the key == ID of the current menu item
		reset($currentItem);//we only expect one item in this array but go back to beginning just in case

		//append the current item's ID
		$itemIDs .= key($currentItem) . ',';

		//the 'parent_id' of the current menu item
		$parentID = isset($menuItems[key($currentItem)]['parent_id']) ? $menuItems[key($currentItem)]['parent_id'] : '';

		//recursively build the breadcrumbs
		$itemIDs .= $this->parents($parentID, $menuItems);
		$itemIDs = rtrim($itemIDs, ',');

		if($itemIDs) {
				//array of menu item IDs
				$menuItemsIDs = explode(',', $itemIDs);
				//we reverse the items array, starting with grandparents first....
				$menuItemsIDs = array_reverse($menuItemsIDs, true);			
		}

		if (is_array($menuItemsIDs)) {

				$wTag = $options['wrapper_list_type'];//item wrapper tag. default = <ul>
				$iTag = $options['list_type'];//item tag. default = <li>

				//assign menu css id and class if provided
				$cssMenuID =  $options['menu_css_id'] ? ' id ="' . $options['menu_css_id'] . '" ' : '';
				$cssMenuClass = $options['menu_css_class'] ? 'class ="' . $options['menu_css_class'] . '"' : '';

				//css ID for current menu item {there is only one}
				$itemCurrent = $options['current_css_id'];
				$cssID = strlen($itemCurrent) ? 'id="' . $itemCurrent . '"' : '';

				//build the breadcrumb
				$out = '';

				$out .= "<{$wTag} {$cssMenuID} {$cssMenuClass}>" . "\n";

				//if option to prepend homepage specified, we prepend to menuItemsIDs
				if ($options['prepend_home']) $menuItemsIDs = array_merge(array('Home' => 'Home'), $menuItemsIDs);

				$i = 0;
				$total = count($menuItemsIDs);

				foreach ($menuItemsIDs as $item) {

						//if prepended homepage
						if ($item === 'Home') {
									
									$item = wire('pages')->get('/');									
									$title = $item->title;
									
									//if we prepended homepage AND homepage is also part of this breadcrumb navigation AND we are on the homepage...
									//we exit early to avoid duplicate Home >> Home
									if ($item->id === wire('page')->id)  {
										$out .= !$iTag ? "{$title}" : "<{$iTag} {$cssID} >{$title}</{$iTag}></{$wTag}>";
										
										return $out;
									}
									
									$url = $item->url;
									$newtab = '';

						}

						else {
									$pagesID = isset($menuItems[$item]['pages_id']) ? $menuItems[$item]['pages_id'] : 0;//for PW pages, use their native IDs
									//display saved vs actual/multilingual menu title/label
									if($options['default_title'] == 0 || $pagesID == 0) $title = $menuItems[$item]['title'];
									elseif($options['default_title'] == 1) $title = wire('pages')->get($pagesID)->title;
									$url = $pagesID ? wire('pages')->get($pagesID)->url : $menuItems[$item]['url'];//for PW pages, use their native URLs
									$newtab = isset($menuItems[$item]['newtab']) ? "target='_blank'" : '';
						}

						//ancestor items
						if ($total - $i != 1) {
								$divider = " {$options['divider']} ";//note the spaces before and after!
								//if $iTag is empty, default to <a> instead
								if(!$iTag) $out .= "<a {$newtab} href='{$url}'>{$title}</a>{$divider}";
								else $out.= "<$iTag><a {$newtab} href='{$url}'>{$title}</a>{$divider}</$iTag>";
						}

						//the last breadcrumb item, i.e., the current page
						else {
								$out .= !$iTag ? "{$title}" : "<{$iTag} {$cssID} >{$title}</{$iTag}>";
						}

						$i++;
				
				}//end foreach

				$out .= "</{$wTag}>";

				return $out;

		}

	}

	/**
	* Helper function to find Menu Builder IDs of the parent of the current menu item.
	* 
	* A recursive function to return IDs of ancestral parents of the current menu item.
	*
	* @access public
	* @param Page $id ID of the parent of the current item.
	* @param Array $menuItems Array of menu items to traverse to locate direct ancestors of the current menu item.
	* @return string $out
	*
	*/
	private function parents($id, Array $menuItems) {

		$out = '';

		if(isset($menuItems[$id]['parent_id'])) {
				$out .= $id . ',';
				$parentID = $menuItems[$id]['parent_id'];						
				//recursively get the next parent item (ancestry: parent, grandparent, great...etc)
				$out .= $this->parents($parentID, $menuItems);
		}

		else {
				//top-most parent
				$out .= $id;
		}

		return $out;

	}

	/**
	* Helper function to process menu options, overwriting defaults.
	* 
	* The options are css and markup related.
	*
	* @access private
	* @param Array $options Array of menu options.
	* @return Array $options
	*
	*/
	private function processOptions(Array $options = null) {

		//default (mainly css) menu options. For css, we make no assumptions & don't output default values
		//shared with renderBreadcrumbs() where applicable
		$defaultOptions = array(

				'wrapper_list_type' => 'ul',//ul, ol, nav, div, etc.
				'list_type' => 'li',//li, a, span, etc.
				'menu_css_id' => '',
				'menu_css_class' => '',
				'submenu_css_class' => '',//NOT for breadcrumbs
				'has_children_class' => '',//any menu item that has children - NOT for breadcrumbs
				'first_class'=>'',//NOT for breadcrumbs
				'last_class' => '',//NOT for breadcrumbs
				'current_class' => '',//NOT for breadcrumbs
				'current_css_id' => '',//only for breadcrumbs
				'divider' => '&raquo;',//only for breadcrumbs
				//prepend home page at the as topmost item even if it isn't part of the breadcrumb
				'prepend_home' => 0,//only for breadcrumbs => 0=no;1=yes
				'default_title' => 0,

		);

		//merge menu options set by user
		if($options != null && is_array($options)) $options = array_merge($defaultOptions, $options);
		else $options = $defaultOptions;

		return $options;

	}

	/**
	* Helper function to return IDs of parent menu items.
	* 
	* These are eventually passed to renderMenu() as the 3rd parameter.
*	*
	* @access private
	* @param Array $menuItems Array of menu items to select parents from.
	* @return Array $parentIDs
	*
	*/
	private function parentIDs(Array $menuItems) {

		$parentIDs = array();

		//overwrite 'parent_id' until last item
		foreach ($menuItems as $key => $value) if (isset($value['parent_id'])) $parentIDs[$value['parent_id']] = $key;

		return $parentIDs;

	}

	/**
	* Helper function to throw error or return false.
	* 
	* This is called if either no menu or no menu items found.
	* Throws WireException for superusers but returns false for all others.
	*
	* @access public
	* @return WireException or false
	*
	*/
	public function throwError() {

		if($this->user->isSuperuser()) 	throw new WireException($this->_('No menu items found! Confirm that such a menu exists and that it has menu items.'));
		else return false;

	}

}